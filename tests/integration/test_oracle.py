"""Oracle 統合テスト: パース → DB実行 → マッピングの一連フロー検証."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Annotated, Any

import pytest

from sqly import Column, Dialect, ParsedSQL, SqlLoader, create_mapper, escape_like, parse_sql
from sqly.mapper.column import entity

pytestmark = pytest.mark.oracle


@dataclass
class Employee:
    """テスト用エンティティ."""

    id: int
    name: str
    dept_id: int | None = None


@dataclass
class AnnotatedEmployee:
    """Annotated カラムマッピング付きエンティティ."""

    id: Annotated[int, Column("emp_id")]
    name: Annotated[str, Column("emp_name")]
    dept_id: Annotated[int | None, Column("department_id")] = None


@entity(naming="snake_to_camel")
@dataclass
class CamelEmployee:
    """CamelCase カラム名のエンティティ."""

    emp_id: int
    emp_name: str


def _fetch_all(conn: Any, result: ParsedSQL) -> list[dict]:
    """ParsedSQL を実行し、行辞書のリストを返すヘルパー."""
    cur = conn.cursor()
    cur.execute(result.sql, result.named_params)
    cur.rowfactory = lambda *args: dict(zip([d[0].lower() for d in cur.description], args))
    return list(cur.fetchall())


@pytest.fixture
def db(oracle_conn: Any) -> Any:
    """テスト用テーブルを作成し、テストデータを投入する."""
    cur = oracle_conn.cursor()
    cur.execute("""
        BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE employees';
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -942 THEN RAISE; END IF;
        END;
    """)
    cur.execute("""
        CREATE TABLE employees (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name VARCHAR2(255) NOT NULL,
            dept_id NUMBER
        )
    """)
    cur.executemany(
        "INSERT INTO employees (id, name, dept_id) VALUES (:1, :2, :3)",
        [
            (1, "Alice", 10),
            (2, "Bob", 20),
            (3, "Charlie", 10),
            (4, "Diana", None),
        ],
    )
    oracle_conn.commit()
    yield oracle_conn
    cur.execute("DROP TABLE employees")
    oracle_conn.commit()


@pytest.fixture
def db_aliased(oracle_conn: Any) -> Any:
    """エイリアス付きカラム名の DB を作成する."""
    cur = oracle_conn.cursor()
    cur.execute("""
        BEGIN
            EXECUTE IMMEDIATE 'DROP TABLE employees_aliased';
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -942 THEN RAISE; END IF;
        END;
    """)
    cur.execute("""
        CREATE TABLE employees_aliased (
            emp_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            emp_name VARCHAR2(255) NOT NULL,
            department_id NUMBER
        )
    """)
    cur.executemany(
        "INSERT INTO employees_aliased (emp_id, emp_name, department_id) VALUES (:1, :2, :3)",
        [
            (1, "Alice", 10),
            (2, "Bob", 20),
        ],
    )
    oracle_conn.commit()
    yield oracle_conn
    cur.execute("DROP TABLE employees_aliased")
    oracle_conn.commit()


class TestBasicFlow:
    """基本フロー: パース → 実行 → マッピング."""

    def test_select_all(self, db: Any) -> None:
        """全件取得."""
        sql = "SELECT * FROM employees ORDER BY id"
        result = parse_sql(sql, {}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 4
        assert employees[0] == Employee(id=1, name="Alice", dept_id=10)

    def test_select_with_param(self, db: Any) -> None:
        """パラメータ付き検索."""
        sql = "SELECT * FROM employees WHERE id = /* $id */999"
        result = parse_sql(sql, {"id": 2}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 1
        assert employees[0] == Employee(id=2, name="Bob", dept_id=20)


class TestLineRemoval:
    """行削除 → 実行 → マッピング."""

    def test_none_param_removes_condition(self, db: Any) -> None:
        """None パラメータで条件行が削除され、全件返る."""
        sql = "SELECT * FROM employees\nWHERE\n    name = /* $name */'default'"
        result = parse_sql(sql, {"name": None}, dialect=Dialect.ORACLE)
        assert "WHERE" not in result.sql
        rows = _fetch_all(db, result)
        assert len(rows) == 4

    def test_partial_removal(self, db: Any) -> None:
        """一部条件のみ削除、残った条件でフィルタリング."""
        sql = (
            "SELECT * FROM employees\n"
            "WHERE\n"
            "    dept_id = /* $dept_id */999\n"
            "    AND name = /* $name */'default'"
        )
        result = parse_sql(sql, {"dept_id": 10, "name": None}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 2
        assert all(e.dept_id == 10 for e in employees)

    def test_all_conditions_none(self, db: Any) -> None:
        """全条件 None で WHERE ごと削除、全件返る."""
        sql = (
            "SELECT * FROM employees\n"
            "WHERE\n"
            "    dept_id = /* $dept_id */999\n"
            "    AND name = /* $name */'default'"
        )
        result = parse_sql(sql, {"dept_id": None, "name": None}, dialect=Dialect.ORACLE)
        assert "WHERE" not in result.sql
        rows = _fetch_all(db, result)
        assert len(rows) == 4


class TestInClause:
    """IN 句展開 → 実行 → マッピング."""

    def test_in_clause_list(self, db: Any) -> None:
        """IN 句でリスト検索."""
        sql = "SELECT * FROM employees WHERE id IN /* $ids */(999)"
        result = parse_sql(sql, {"ids": [1, 3]}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 2
        assert {e.id for e in employees} == {1, 3}

    def test_in_clause_single(self, db: Any) -> None:
        """IN 句で単一要素リスト."""
        sql = "SELECT * FROM employees WHERE id IN /* $ids */(999)"
        result = parse_sql(sql, {"ids": [2]}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        assert len(rows) == 1
        assert rows[0]["name"] == "Bob"

    def test_in_clause_empty_list(self, db: Any) -> None:
        """IN 句で空リスト → NULL → 0件."""
        sql = "SELECT * FROM employees WHERE id IN /* $ids */(999)"
        result = parse_sql(sql, {"ids": []}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        assert len(rows) == 0


class TestAnnotatedColumnMapping:
    """Annotated[T, Column('X')] によるカラムマッピング統合テスト."""

    def test_annotated_mapping(self, db_aliased: Any) -> None:
        """DB カラム名→フィールド名のマッピングが動作する."""
        sql = "SELECT * FROM employees_aliased ORDER BY emp_id"
        result = parse_sql(sql, {}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db_aliased, result)
        mapper = create_mapper(AnnotatedEmployee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 2
        assert employees[0] == AnnotatedEmployee(id=1, name="Alice", dept_id=10)


class TestEntityDecorator:
    """@entity デコレータ統合テスト."""

    def test_naming_convention_mapping(self, oracle_conn: Any) -> None:
        """Snake_to_camel naming でカラムマッピング."""
        cur = oracle_conn.cursor()
        cur.execute("""
            BEGIN
                EXECUTE IMMEDIATE 'DROP TABLE "camelEmployees"';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -942 THEN RAISE; END IF;
            END;
        """)
        cur.execute("""
            CREATE TABLE "camelEmployees" (
                "empId" NUMBER PRIMARY KEY,
                "empName" VARCHAR2(255) NOT NULL
            )
        """)
        cur.execute("""INSERT INTO "camelEmployees" ("empId", "empName") VALUES (1, 'Alice')""")
        oracle_conn.commit()

        sql = 'SELECT * FROM "camelEmployees"'
        result = parse_sql(sql, {}, dialect=Dialect.ORACLE)
        rows = _fetch_all(oracle_conn, result)
        mapper = create_mapper(CamelEmployee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 1
        assert employees[0] == CamelEmployee(emp_id=1, emp_name="Alice")

        cur.execute('DROP TABLE "camelEmployees"')
        oracle_conn.commit()


class TestSqlLoaderIntegration:
    """SqlLoader → パース → 実行 → マッピングの一連フロー."""

    def test_load_and_execute(self, db: Any, tmp_path: Path) -> None:
        """SQL ファイルを読み込んでパース・実行・マッピング."""
        sql_dir = tmp_path / "sql"
        sql_dir.mkdir()
        (sql_dir / "find_by_dept.sql").write_text(
            "SELECT * FROM employees\nWHERE\n    dept_id = /* $dept_id */999",
            encoding="utf-8",
        )

        loader = SqlLoader(sql_dir)
        sql_template = loader.load("find_by_dept.sql")
        result = parse_sql(sql_template, {"dept_id": 10}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 2
        assert all(e.dept_id == 10 for e in employees)

    def test_load_with_none_param(self, db: Any, tmp_path: Path) -> None:
        """SQL ファイルを読み込み、None パラメータで条件削除."""
        sql_dir = tmp_path / "sql"
        sql_dir.mkdir()
        (sql_dir / "search.sql").write_text(
            "SELECT * FROM employees\n"
            "WHERE\n"
            "    dept_id = /* $dept_id */999\n"
            "    AND name = /* $name */'default'",
            encoding="utf-8",
        )

        loader = SqlLoader(sql_dir)
        sql_template = loader.load("search.sql")
        result = parse_sql(sql_template, {"dept_id": None, "name": "Alice"}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 1
        assert employees[0].name == "Alice"


class TestMultipleParams:
    """複数パラメータの組み合わせ."""

    def test_multiple_conditions(self, db: Any) -> None:
        """複数条件でフィルタリング."""
        sql = (
            "SELECT * FROM employees\n"
            "WHERE\n"
            "    dept_id = /* $dept_id */999\n"
            "    AND name = /* $name */'default'"
        )
        result = parse_sql(sql, {"dept_id": 10, "name": "Alice"}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 1
        assert employees[0] == Employee(id=1, name="Alice", dept_id=10)

    def test_in_clause_with_regular_param(self, db: Any) -> None:
        """IN 句と通常パラメータの混在."""
        sql = (
            "SELECT * FROM employees\n"
            "WHERE dept_id = /* $dept_id */999\n"
            "  AND id IN /* $ids */(999)"
        )
        result = parse_sql(sql, {"dept_id": 10, "ids": [1, 3]}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 2
        assert {e.name for e in employees} == {"Alice", "Charlie"}


class TestNullHandling:
    """NULL 値の扱い."""

    def test_non_removable_null_param(self, db: Any) -> None:
        """非 removable パラメータの None は NULL バインド."""
        sql = "SELECT * FROM employees WHERE dept_id = /* dept_id */999"
        result = parse_sql(sql, {"dept_id": None}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        # Oracle の WHERE dept_id = NULL は0件（IS NULL が必要）
        assert len(rows) == 0

    def test_select_null_field(self, db: Any) -> None:
        """NULL フィールドを持つレコードのマッピング."""
        sql = "SELECT * FROM employees WHERE id = /* $id */999"
        result = parse_sql(sql, {"id": 4}, dialect=Dialect.ORACLE)
        rows = _fetch_all(db, result)
        mapper = create_mapper(Employee)
        employees = mapper.map_rows(rows)
        assert len(employees) == 1
        assert employees[0] == Employee(id=4, name="Diana", dept_id=None)


class TestDialectInClauseSplit:
    """IN 句分割統合テスト (TASK-033)."""

    @pytest.fixture
    def db_large(self, oracle_conn: Any) -> Any:
        """大量データ用テーブル."""
        cur = oracle_conn.cursor()
        cur.execute("""
            BEGIN
                EXECUTE IMMEDIATE 'DROP TABLE large_data';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -942 THEN RAISE; END IF;
            END;
        """)
        cur.execute("""
            CREATE TABLE large_data (
                id NUMBER PRIMARY KEY,
                val VARCHAR2(10)
            )
        """)
        # 1500件挿入（1000件制限を超える）
        cur.executemany(
            "INSERT INTO large_data (id, val) VALUES (:1, :2)",
            [(i, f"v{i}") for i in range(1, 1501)],
        )
        oracle_conn.commit()
        yield oracle_conn
        cur.execute("DROP TABLE large_data")
        oracle_conn.commit()

    def test_in_clause_split_over_1000(self, db_large: Any) -> None:
        """1000件超のIN句が自動分割される."""
        ids = list(range(1, 1201))  # 1200件
        sql = "SELECT COUNT(*) as cnt FROM large_data WHERE id IN /* $ids */(999)"
        result = parse_sql(sql, {"ids": ids}, dialect=Dialect.ORACLE)
        # SQL が分割されているか確認（OR が含まれる）
        assert " OR " in result.sql
        cur = db_large.cursor()
        cur.execute(result.sql, result.named_params)
        row = cur.fetchone()
        assert row[0] == 1200

    def test_in_clause_no_split_under_1000(self, db_large: Any) -> None:
        """1000件以下のIN句は分割されない."""
        ids = list(range(1, 501))  # 500件
        sql = "SELECT COUNT(*) as cnt FROM large_data WHERE id IN /* $ids */(999)"
        result = parse_sql(sql, {"ids": ids}, dialect=Dialect.ORACLE)
        # SQL が分割されていないか確認（OR が含まれない）
        assert " OR " not in result.sql
        cur = db_large.cursor()
        cur.execute(result.sql, result.named_params)
        row = cur.fetchone()
        assert row[0] == 500

    def test_in_clause_exact_1000(self, db_large: Any) -> None:
        """ちょうど1000件のIN句は分割されない."""
        ids = list(range(1, 1001))  # 1000件
        sql = "SELECT COUNT(*) as cnt FROM large_data WHERE id IN /* $ids */(999)"
        result = parse_sql(sql, {"ids": ids}, dialect=Dialect.ORACLE)
        assert " OR " not in result.sql
        cur = db_large.cursor()
        cur.execute(result.sql, result.named_params)
        row = cur.fetchone()
        assert row[0] == 1000


class TestDialectLikeEscape:
    """LIKE エスケープ統合テスト (TASK-034)."""

    @pytest.fixture
    def db_with_special_names(self, oracle_conn: Any) -> Any:
        """特殊文字を含む名前のテストデータ."""
        cur = oracle_conn.cursor()
        cur.execute("""
            BEGIN
                EXECUTE IMMEDIATE 'DROP TABLE products';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -942 THEN RAISE; END IF;
            END;
        """)
        cur.execute("""
            CREATE TABLE products (
                id NUMBER PRIMARY KEY,
                name VARCHAR2(255) NOT NULL
            )
        """)
        cur.executemany(
            "INSERT INTO products (id, name) VALUES (:1, :2)",
            [
                (1, "10% OFF Sale"),
                (2, "Product_A"),
                (3, "C# Programming"),
                (4, "Normal Product"),
                (5, "100％達成"),  # 全角パーセント
            ],
        )
        oracle_conn.commit()
        yield oracle_conn
        cur.execute("DROP TABLE products")
        oracle_conn.commit()

    def test_like_escape_percent(self, db_with_special_names: Any) -> None:
        """% を含む値を LIKE 検索."""
        search = escape_like("10%", Dialect.ORACLE)
        sql = "SELECT * FROM products WHERE name LIKE /* $pattern */'%' ESCAPE '#'"
        result = parse_sql(sql, {"pattern": f"{search}%"}, dialect=Dialect.ORACLE)
        cur = db_with_special_names.cursor()
        cur.execute(result.sql, result.named_params)
        cur.rowfactory = lambda *args: dict(zip([d[0].lower() for d in cur.description], args))
        rows = list(cur.fetchall())
        assert len(rows) == 1
        assert rows[0]["name"] == "10% OFF Sale"

    def test_like_search_fullwidth_chars(self, db_with_special_names: Any) -> None:
        """全角文字を含む値を LIKE 検索.

        Note:
            全角 ``％`` ``＿`` は Oracle の LIKE ワイルドカードではないため、
            エスケープ不要でそのまま検索できる。
        """
        # 全角％はワイルドカードではないのでエスケープ不要
        sql = "SELECT * FROM products WHERE name LIKE /* $pattern */'%'"
        result = parse_sql(sql, {"pattern": "100％%"}, dialect=Dialect.ORACLE)
        cur = db_with_special_names.cursor()
        cur.execute(result.sql, result.named_params)
        cur.rowfactory = lambda *args: dict(zip([d[0].lower() for d in cur.description], args))
        rows = list(cur.fetchall())
        assert len(rows) == 1
        assert rows[0]["name"] == "100％達成"


class TestDialectSqlLoaderIntegration:
    """Dialect 別 SQL ファイルロード統合テスト (TASK-035)."""

    def test_dialect_specific_file(self, db: Any, tmp_path: Path) -> None:
        """Dialect 固有ファイルが優先される."""
        sql_dir = tmp_path / "sql"
        sql_dir.mkdir()
        # 汎用ファイル
        (sql_dir / "count.sql").write_text(
            "SELECT COUNT(*) as cnt FROM employees",
            encoding="utf-8",
        )
        # Oracle 固有ファイル（ROWNUM使用）
        (sql_dir / "count.oracle.sql").write_text(
            "SELECT COUNT(*) as cnt FROM employees WHERE ROWNUM <= 3",
            encoding="utf-8",
        )

        loader = SqlLoader(sql_dir)
        sql_template = loader.load("count.sql", dialect=Dialect.ORACLE)
        result = parse_sql(sql_template, {}, dialect=Dialect.ORACLE)
        cur = db.cursor()
        cur.execute(result.sql, result.named_params)
        row = cur.fetchone()
        # Oracle 固有ファイルが使われ、ROWNUM <= 3 で3件
        assert row[0] == 3

    def test_dialect_fallback_to_generic(self, db: Any, tmp_path: Path) -> None:
        """Dialect 固有ファイルがなければ汎用ファイルにフォールバック."""
        sql_dir = tmp_path / "sql"
        sql_dir.mkdir()
        (sql_dir / "count.sql").write_text(
            "SELECT COUNT(*) as cnt FROM employees",
            encoding="utf-8",
        )

        loader = SqlLoader(sql_dir)
        # PostgreSQL固有ファイルは存在しないのでフォールバック
        sql_template = loader.load("count.sql", dialect=Dialect.POSTGRESQL)
        result = parse_sql(sql_template, {}, dialect=Dialect.ORACLE)  # 実行はOracle
        cur = db.cursor()
        cur.execute(result.sql, result.named_params)
        row = cur.fetchone()
        assert row[0] == 4
