# コードレビュー 2026-03-01

対象: sqlym v1.0 全ソースコード (`src/sqlym/`)

## 総評

全体として品質は高く、v1.0 リリースに適した状態である。
527テスト、92% カバレッジ。設計ドキュメント (SPEC.md / DESIGN.md) との整合性も高い。

初回レビューでは CRITICAL 3件、WARNING 9件、INFO 7件を検出したが、
議論の結果 CRITICAL 2件と WARNING 3件を棄却した。
棄却の主因は、レビュー基準のチェックリストを**コードの文脈を理解せずに
機械的に適用**したことにある。具体的には以下の3点が欠落していた:

1. **レビュー対象の種別判定**: ライブラリとアプリケーションでは
   責務境界が異なる (例: 入力検証はアプリケーション側の責務)
2. **実際の使用文脈の確認**: 理論上のリスクを指摘する前に、
   現実的に発生しうるかを確認すべき
3. **チェックリスト適用前の文脈確認**: 上記2点を包含する上位原則

この教訓を受けて `core/review-standards.md` に「Context Assessment」セクションを
追加し、チェックリスト適用の前提条件として明文化した。

### 優れている点

- 設計ドキュメントとの高い整合性。API 設計が一貫している
- パーサー系テストが特に網羅的。統合テストで SQLite を使った E2E フローも確認済み
- ゼロ依存設計。`TYPE_CHECKING` ガードや遅延インポートが適切
- Protocol ベースのマッパー設計で拡張性が高い
- パストラバーサル対策、厳格な Ruff 設定などセキュリティ意識が高い
- クリーンな例外階層と一貫した Google style docstring

## CRITICAL

### C-1: 本番コードで `assert` を使用

- **場所**: `parser/twoway.py:345`
- **内容**: `-O` フラグで除去されるため、明示的な `if` チェック + 例外送出に変更すべき
- **修正案**:

```python
# Before
assert if_directive is not None and if_directive.type == DirectiveType.IF

# After
if if_directive is None or if_directive.type != DirectiveType.IF:
    msg = f"Expected IF directive at line {units[start_idx].line_number}"
    raise SqlParseError(msg)
```

## WARNING

### W-1: `_mapping_cache` が無制限に成長する

- **場所**: `mapper/dataclass.py:15`
- **内容**: `ClassVar[dict[type, dict[str, str]]]` で無制限に成長する。動的にクラスを生成するアプリケーションではメモリリークの可能性がある
- **修正案**: `weakref.WeakKeyDictionary` の使用を検討

### W-2: `PydanticMapper` のテストカバレッジが 0%

- **場所**: `mapper/pydantic.py`
- **内容**: Pydantic はオプション依存だが、v1.0 としてリリースするなら基本的なテストが必要
- **修正案**: `pydantic` を `dev` dependency に追加し CI でテスト実行する

### W-3: `insert()` メソッドのテストカバレッジ不足

- **場所**: `sqlym.py:172-201`
- **内容**: `insert()` メソッドが全くテストされていない (lines 187-201 が未カバー)
- **修正案**: `TestSqlymIntegration` に `test_insert()` を追加する

### W-4: `cursor.description` が None の場合にクラッシュ

- **場所**: `sqlym.py:218`
- **内容**: `cursor.description` は結果セットを返さないクエリで `None` を返す可能性がある (PEP 249)
- **修正案**:

```python
if cursor.description is None:
    return []
columns = [desc[0] for desc in cursor.description]
```

### W-5: `parse()` が `self.original_sql` を変更する副作用

- **場所**: `parser/twoway.py:170`
- **内容**: `%include` 展開時に `self.original_sql` を上書きする。同一インスタンスで `parse()` を2回呼ぶと予期しない動作になる可能性がある
- **修正案**: ローカル変数を使用してイミュータブルに保つ

```python
def parse(self, params: dict[str, Any]) -> ParsedSQL:
    sql = self.original_sql
    if self.base_path is not None:
        sql = self._expand_includes(sql, self.base_path, included_files=set())
    units = self._parse_lines(sql)
    ...
```

## INFO

### I-1: `parser/__init__.py` が空ファイル

- **場所**: `parser/__init__.py`
- **内容**: `__all__` を定義して公開 API を明示すると良い。`mapper/__init__.py` では適切に定義されている

### I-2: `escape_utils.py` の docstring が実装と不一致

- **場所**: `escape_utils.py:16`
- **内容**: docstring に「Oracle では全角ワイルドカードも対象」と記載があるが、実装では全角文字はエスケープ対象に含まれていない。docstring を実装に合わせて修正すべき

### I-3: `LineUnit` にカスタム `__repr__` がない

- **場所**: `parser/line_unit.py`
- **内容**: デバッグ時に内容を確認しにくい。`parent`/`children` の再帰表示が問題になる可能性もある
- **修正案**:

```python
def __repr__(self) -> str:
    return (
        f"LineUnit(line={self.line_number}, "
        f"indent={self.indent}, removed={self.removed})"
    )
```

### I-4: エラーメッセージキーがハードコードされた文字列

- **場所**: `parser/twoway.py:1288-1318`
- **内容**: タイポがあってもランタイムまで検出できない。`Enum` やモジュールレベルの定数でキーを定義すると安全性が向上する

### I-5: `Column` に `__eq__`/`__hash__` が未定義

- **場所**: `mapper/column.py:8-15`
- **内容**: 値オブジェクトとして使われるが等値比較ができない
- **修正案**: `@dataclass(frozen=True)` にする

### I-6: `execute()` と `insert()` のコード重複

- **場所**: `sqlym.py:141-201`
- **内容**: SQL ロード・パース・カーソル実行部分がほぼ同一。共通メソッドに抽出を推奨

### I-7: `entity` デコレータが `naming` の無効値を検証していない

- **場所**: `mapper/column.py:18-40`
- **内容**: 無効な値を渡してもエラーにならず、黙ってフィールド名そのままになる
- **修正案**:

```python
_VALID_NAMING = {"as_is", "snake_to_camel", "camel_to_snake"}

def entity(cls=None, *, column_map=None, naming="as_is") -> Any:
    if naming not in _VALID_NAMING:
        msg = f"Invalid naming: {naming!r}. Must be one of {_VALID_NAMING}"
        raise ValueError(msg)
    ...
```

## 議論の結果取り下げた指摘

| 旧番号 | 内容 | 取り下げ理由 |
| --- | --- | --- |
| C-1 | `%STR`/`%SQL` のSQLインジェクション防止策の欠如 | 通常パラメータはバインド処理済み。`%STR`/`%SQL` は意図的な直接埋め込み機能であり、入力検証はアプリケーション側の責務 |
| C-2 | `is_negative` のリスト再帰に深さ制限なし | SQLパラメータとして深くネストしたリストが渡されることは実用上ない |
| W-5 | `config.py` のグローバル変数がスレッドセーフでない | 起動時に設定し以降変更しないのは自明な使い方 |
| W-7 | `_resolve_value` 等の `token` パラメータ型が `Any` | 複数の異なる正規表現マッチ結果から生成されるため `Any` でしか受けられない |
| W-8 | `dialect._dialect_id` プライベート属性の直接参照 | 同一パッケージ内でのプライベート属性参照であり問題なし |
